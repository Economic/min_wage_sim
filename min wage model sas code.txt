/***********************************************************************************************************/
/* This program uses CPS ORG data to: 1) Identify and describe the number of people who would be directly 
/* affected by a minimum wage increase; 2) Estimate the number of people indirectly affected by an increase; 
/* 3) Calculate the wage bill increase; and 4) model these calculations with a multi-year, phased increase in the MW. 
/* This program accounts for existing state minimum wage increases scheduled under current law.
/*
/* D. Cooper - 11/17/16*/
/*  Fixed kids overcounting
/*  Fixed state MW increases issue 11/14/13
/* FIXED Indirectly affected average raise data - 9/1/2016
/* New program to model Federal $15 by 2025 proposal - 3/31/2018
/************************************************************************************************************/
quit;
libname qorg 'E:\fdata1\EARNdata\MORG\topcd\';
libname org 'E:\fdata0\org2\topcd';
libname external 'E:\userfiles\dcooper\Minimum Wage\new spillover\data';
libname vorg 'e:\fdata1\dcooper\org\';

/* These variables must be changed depending on proposal being analyzed*/
%let year_data = 2016; *The year of most recent data;

%let wagegrowth1=1.0248; *Assuming 2.48% growth from 2015-2016 - Jan-Oct growth;
%let monthstoincrease1 = 12; *given that we usually use full-year data from the previous year, I tend to make this how many months into the current year before the first increase;
%let year_proposal1 = 2017; *the first year the proposal will be implemented;
%let month_pre_proposal1 = 7; *the month of the first proposed increase.   DC(10/3/11): Typically the increases occur on jan 1,so applying the previous month's rate requires bridging years, 
which the program is not designed to do. So we you can set this to Jan as if it were a Feb increase if needed.;
%let newrate1 = 9.25; *the new minimum wage in the first increase;
%let tiprate1 = 4.15;

/*multi-year proposals only */

%let wagegrowth2=1.03; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease2 = 12; *the number of months between the first and second increase;
%let year_proposal2 = 2018; *the second year of the proposed phased increase;
%let month_pre_proposal2 = 7; *the month of the second proposed phased increase;
%let newrate2 = 10.10; *the new minimum wage in the second increase;
%let tiprate2 = 5.30;

%let wagegrowth3=1.028; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease3 = 12; *the number of months between the second and third increase;
%let year_proposal3 = 2019; *the third year of the proposed phased increase;
%let month_pre_proposal3 = 7; *the month of the third proposed phased increase;
%let newrate3 = 11.00; *the new miniumum wage in the third increase;
%let tiprate3 = 6.45;

%let wagegrowth4=1.028; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease4 = 12; 
%let year_proposal4 = 2020; 
%let month_pre_proposal4 = 7; 
%let newrate4 = 12.00; *the new miniumum wage in the fourth increase;
%let tiprate4 = 7.60;

%let wagegrowth5=1.029; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease5 = 12; 
%let year_proposal5 = 2021; 
%let month_pre_proposal5 = 7; 
%let newrate5 = 13.00; *the new miniumum wage in the fifth increase;
%let tiprate5 = 8.75;

%let wagegrowth6=1.029; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease6 = 12;
%let year_proposal6 = 2022; 
%let month_pre_proposal6 = 7; 
%let newrate6 = 13.50; *the new miniumum wage in the sixth increase;
%let tiprate6 = 9.90;

%let wagegrowth7=1.029; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease7 = 12; 
%let year_proposal7 = 2023; 
%let month_pre_proposal7 = 7; 
%let newrate7 = 14.25; *the new miniumum wage in the seventh increase;
%let tiprate7 = 11.05;

%let wagegrowth8=1.029; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease8 = 12; 
%let year_proposal8 = 2024; 
%let month_pre_proposal8 = 7; 
%let newrate8 = 15.00; *the new miniumum wage in the eighth increase;
%let tiprate8 = 12.20;

%let wagegrowth9=1.00; *CBO's projections for CPI plus 0.5%;
%let monthstoincrease9 = 1; 
%let year_proposal9 = 2025; 
%let month_pre_proposal9 = 1; 
%let newrate9 = 15.00; *the new miniumum wage in the ninth increase;
%let tiprate9 = 12.20;

%let growthdum = 1; *Dummy to indicate the inclusion of wagegrowth bottom 20%;

%let popgrowthw = 0.997; *projected annual labor force growth rate for non-Hispanic whites 2014-2024 per BLS;
%let popgrowthb = 1.01; *projected annual labor force growth rate for Blacks 2014-2024 per BLS;
%let popgrowthh = 1.025; *projected annual labor force growth rate for Hispanics 2014-2024 per BLS;
%let popgrowtha = 1.021; *projected annual labor force growth rate for Asians 2014-2024 per BLS;
%let popgrowtho = 1.02; *projected annual labor force growth rate for other race/ethnicities 2014-2024 per BLS;

*USE http://www.census.gov/population/projections/data/state/st-prod-proj-list.html for individual state projected growth;

%let numsteps=9; *Change to indicate number of total iterations;
	
/*state level calculations only */

*%let targetstate = 52; *State of proposed minimum wage increase. Disable for national calculations;

*%let conds=(worker=1 and state=&targetstate);*use for single state-level analysis.  STILL NEED TO CHANGE CONDS LINE FOR KIDS METRICS;
%let conds=(worker=1); *use for national-level analysis;
*%let conds=(worker=1 and state=&targetstate and cbsa=35620 and cencity=1); *for city-level analyses. Use ACS instead.;

*%let kconds=(state=&targetstate and cbsa=35620 and cencity=1); *for city-level;
*%let kconds=(state=&targetstate);
%let kconds=(pop=1);

%let outfile = 'R:\new_R_drive_structure\EARN\Minimum Wage\2015_2017\USA\RAW\US 15 by 2024 w_freq.xls'; *File where SAS will output the data;

%let yr=%substr(&year_data,3,2); *two digit year - no need to modify;
run;

%macro alertme(); *plays sound that program is complete;
 DATA _NULL_;* this produces a
   series of tones and serves as a
   signal that SAS has reached
   this point in a program;
      Do i = 200 to  2500 by 250
   ;
           call sound(i,100);
      end;
   run;
%mend alertme;

%macro cut(st);
proc univariate data=wage_mins(where=(worker=1)) noprint;
var wage4 indirect_cutoff&st;
weight wgt;
output out=cut&st mean=mwage cutoff pctlpre=cut pctlpts=5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95;
run;

%if &st=1 %then %do;
	data cutout;
	set cut&st;
	%end;
%else %do;
	data cutout;
	set cutout cut&st;
	%end;

data freqset;
set wage_mins(where=(worker=1));

if 0<wage4<6.25 then wb='0)0-6.25      ';
else if 6.25<=wage4<6.75 then wb='1)6.25-6.75    ';
else if 6.75<=wage4<7.25 then wb='2)6.75-7.25    ';
else if 7.25<=wage4<7.75 then wb='3)7.25-7.75    ';
else if 7.75<=wage4<8.25 then wb='4)7.75-8.25    ';
else if 8.25<=wage4<8.75 then wb='5)8.25-8.75    ';
else if 8.75<=wage4<9.25 then wb='6)8.75-9.25    ';
else if 9.25<=wage4<9.75 then wb='7)9.25-9.75    ';
else if 9.75<=wage4<10.25 then wb='8)9.75-10.25    ';
else if 10.25<=wage4<10.75 then wb='9)10.25-10.75    ';
else if 10.75<=wage4<11.25 then wb='10)10.25-11.25    ';
else if 11.25<=wage4<11.75 then wb='11)11.25-11.75    ';
else if 11.75<=wage4<12.25 then wb='12)11.75-12.25    ';
else if 12.25<=wage4<12.75 then wb='13)12.25-12.75    ';
else if 12.75<=wage4<13.25 then wb='14)12.75-13.25    ';
else if 13.25<=wage4<13.75 then wb='15)13.25-13.75    ';
else if 13.75<=wage4<14.25 then wb='16)13.75-14.25    ';
else if 14.25<=wage4<14.75 then wb='17)14.25-14.75    ';
else if 14.75<=wage4<15.25 then wb='18)14.75-15.25    ';
else if 15.25<=wage4<15.75 then wb='19)15.25-15.75    ';
else if 15.75<=wage4<16.25 then wb='20)15.75-16.25    ';
else if 16.25<=wage4<16.75 then wb='21)16.25-16.75    ';
else if 16.75<=wage4<17.25 then wb='22)16.75-17.25    ';
else if 17.25<=wage4<17.75 then wb='23)17.25-17.75    ';
else if 17.75<=wage4<18.25 then wb='24)17.75-18.25    ';
else if 18.25<=wage4<18.75 then wb='25)18.25-18.75    ';
else if 18.75<=wage4<19.25 then wb='26)18.75-19.25    ';
else if 19.25<=wage4<19.75 then wb='27)19.25-19.75    ';
else if 19.75<=wage4 then wb='28)19.75 or higher    ';
else wb='n/a';

proc freq data=freqset noprint;
tables wb/out=freq&st;
weight wgt;
run;

data freq&st(rename=(COUNT=Count&st PERCENT=Percent&st));
set freq&st;
percent=percent/100;

%if &st=1 %then %do;
	data freqout;
	set freq&st;
	%end;
%else %do;
	data freqout;
	merge freqout freq&st;
	by wb;
	%end;

RUN;
%mend;

/*******************************************************************/
/*****************************YEAR 1********************************/
/*******************************************************************/

/*Minimum Wage Datset Construction*/

* First get the current and future min wage data from external file;

data min_current (drop=year rename=(stmin=stmin&year_data tipmin=tipmin&year_data)) ;
	set external.stmins_current (where=(year=&year_data) keep=state year month stmin tipmin);

* Set the future min wage to be the current state min the month before the proposal
	takes effect. This captures states that raise their mins between now and then;
data min_future1 (where=(year=&year_proposal1 and month=&month_pre_proposal1)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future2 (where=(year=&year_proposal2 and month=&month_pre_proposal2)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future3 (where=(year=&year_proposal3 and month=&month_pre_proposal3)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future4 (where=(year=&year_proposal4 and month=&month_pre_proposal4)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future5 (where=(year=&year_proposal5 and month=&month_pre_proposal5)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future6 (where=(year=&year_proposal6 and month=&month_pre_proposal6)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future7 (where=(year=&year_proposal7 and month=&month_pre_proposal7)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future8 (where=(year=&year_proposal8 and month=&month_pre_proposal8)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;

data min_future9 (where=(year=&year_proposal9 and month=&month_pre_proposal9)) ;
	set external.stmins_current (keep=state year month stmin tipmin);
run;


*This dataset has for each state the current min 
 and the future mins to calc directly affected;
*min_current (drop=year rename=(stmin=stmin&year_data));
data mins;
	merge min_future1 (drop=year rename=(stmin=stmin&year_proposal1 tipmin=tipmin&year_proposal1))
		  min_future2 (drop=year rename=(stmin=stmin&year_proposal2 tipmin=tipmin&year_proposal2))
		  min_future3 (drop=year rename=(stmin=stmin&year_proposal3 tipmin=tipmin&year_proposal3))
		  min_future4 (drop=year rename=(stmin=stmin&year_proposal4 tipmin=tipmin&year_proposal4))
		  min_future5 (drop=year rename=(stmin=stmin&year_proposal5 tipmin=tipmin&year_proposal5))
		  min_future6 (drop=year rename=(stmin=stmin&year_proposal6 tipmin=tipmin&year_proposal6))
		  min_future7 (drop=year rename=(stmin=stmin&year_proposal7 tipmin=tipmin&year_proposal7))
		  min_future8 (drop=year rename=(stmin=stmin&year_proposal8 tipmin=tipmin&year_proposal8))
		  min_future9 (drop=year rename=(stmin=stmin&year_proposal9 tipmin=tipmin&year_proposal9));
	by state; *month;
run;

*proc delete data=min_current;
proc delete data=min_future1;
proc delete data=min_future2;
proc delete data=min_future3;
proc delete data=min_future4;
proc delete data=min_future5;
proc delete data=min_future6;
proc delete data=min_future7;
proc delete data=min_future8;
proc delete data=min_future9;
run;

/* Estimate wage and job growth over period of proposed MW increase */
/* Find average wage growth of past three years by state
  and total population growth using estimate of annual growth;
*/

data growth (keep = state avggrowth totalpopgrowthw totalpopgrowthb totalpopgrowthh totalpopgrowtha totalpopgrowtho year1growth);
	set external.growth;
	if _n_ = 1 then delete; *Delete first row of total US data;
	avggrowth = (growth2002 + growth2003 + growth2004 + growth2005 + growth2006)/5;
	year1growth = ((&monthstoincrease1/12)*(&wagegrowth1-1))+1; *change as needed;
    totalpopgrowthw = ((&monthstoincrease1/12)*(&popgrowthw-1))+1;
	totalpopgrowthb = ((&monthstoincrease1/12)*(&popgrowthb-1))+1;
	totalpopgrowthh = ((&monthstoincrease1/12)*(&popgrowthh-1))+1;
	totalpopgrowtha = ((&monthstoincrease1/12)*(&popgrowtha-1))+1;
	totalpopgrowtho = ((&monthstoincrease1/12)*(&popgrowtho-1))+1;
run;

/*CALCULATE DIRECTLY AND INDIRECTLY AFFECTED*/
* Next find directly affected workers
  Those who are earning above the current min but less than proposed min;

* Input most recent data;
data orgdata;
set org.org&yr.c (keep=hhid month state finalwt sex _race race5 orgwt pemlr wage4 age frel 
                         marstat ed majind indcode majocc hourwk famy famwt famid ftype ownchld occode sector cbsa cencity);
	stold=state;*the 2014 data are still coded to the old state format, as are the stmin and wage growth data sets so have to set 2015+ data to 2014 coding;
	select(state);
		when (1) state=63;
		when (2) state=94;
		when (4) state=86;
		when (5) state=71;
		when (6) state=93;
		when (8) state=84;
		when (9) state=16;
		when (10) state=51;
		when (11) state=53;
		when (12) state=59;
		when (13) state=58;
		when (15) state=95;
		when (16) state=82;
		when (17) state=33;
		when (18) state=32;
		when (19) state=42;
		when (20) state=47;
		when (21) state=61;
		when (22) state=72;
		when (23) state=11;
		when (24) state=52;
		when (25) state=14;
		when (26) state=34;
		when (27) state=41;
		when (28) state=64;
		when (29) state=43;
		when (30) state=81;
		when (31) state=46;
		when (32) state=88;
		when (33) state=12;
		when (34) state=22;
		when (35) state=85;
		when (36) state=21;
		when (37) state=56;
		when (38) state=44;
		when (39) state=31;
		when (40) state=73;
		when (41) state=92;
		when (42) state=23;
		when (44) state=15;
		when (45) state=57;
		when (46) state=45;
		when (47) state=62;
		when (48) state=74;
		when (49) state=87;
		when (50) state=13;
		when (51) state=54;
		when (53) state=91;
		when (54) state=55;
		when (55) state=35;
		when (56) state=83;
	end;
run;

proc format;     /*by 9 divisions in full name*/
value statef 
      11=me 12=nh 13=vt 14=ma 15=ri 16=ct 21=ny 22=nj 23=pa 
      31=oh 32=in 33=il 34=mi 35=wi 41=mn 42=ia 43=mo 44=nd 45=sd 46=ne 47=ks 
      51=de 52=md 53=dc 54=va 55=wv 56=nc 57=sc 58=ga 59=fl 61=ky 62=tn 63=al 64=ms 71=ar 72=la 73=ok 74=tx 
      81=mt 82=id 83=wy 84=co 85=nm 86=az 87=ut 88=nv 91=wa 92=or 93=ca 94=ak 95=hi;

*set qorg.org12q4t (keep=hhid month state finalwt sex _race orgwt pemlr wage4 age frel 
                         marstat ed majind indcode majocc hourwk famy famwt famid ftype ownchld occode sector cbsa cencity)
	qorg.org13q1t (keep=hhid month state finalwt sex _race orgwt pemlr wage4 age frel 
                         marstat ed majind indcode majocc hourwk famy famwt famid ftype ownchld occode sector cbsa cencity)
	qorg.org13q2t (keep=hhid month state finalwt sex _race orgwt pemlr wage4 age frel 
                         marstat ed majind indcode majocc hourwk famy famwt famid ftype ownchld occode sector cbsa cencity)
	qorg.org13q3t (keep=hhid month state finalwt sex _race orgwt pemlr wage4 age frel 
                         marstat ed majind indcode majocc hourwk famy famwt famid ftype ownchld occode sector cbsa cencity);  
*/run;

proc sort data=orgdata;
	by state month;
run;

proc sort data=min_current;
	by state month;
run;

data org_growth;
 merge orgdata min_current;
 by state month;
 run;

*Combine wagegrowth data with ORG data;
data org_growth;
  merge org_growth growth;
  by state;
run;


* Combine min wage data with ORG data;
data wage_mins;
 merge org_growth mins;
 by state; *month;

 *Then create some new vars in this dataset;
*wgt=orgwt*totalpopgrowth/12; *used to annualize the ORG weight and get actual pop count;
*wgt=(orgwt/12)*totalpopgrowth; *Moved to race designations to grow at projections by race/ethnicity;
*pwt = (finalwt*4/12)*totalpopgrowth; *annualize finalwt and adjust for ORG sample;
*vetwgt=vetwgt/10000;
*vwgt=vetwgt*4/12;

pop=1;
raise=.;
draise=.;
iraise=.;
worker=0;

if age>=18 then adult=1;
else adult=0;

famid_2 = hhid*100+month;

* Create demographic categories;
if 16<=age<20 then agec1='Under 20';
  else agec1='20 + ';

if age<25 then agec2='16 to 24    ';
else if 25<=age<40 then agec2='25 to 39';
else if 40<=age<55 then agec2='40 to 54';
else if age>=55 then agec2='55+';

if sex=1 then sexc='Male                              ';
  else sexc='Female    ';

if race5=1 then do;
	rc='1White             ';
	wgt=(orgwt/12)*totalpopgrowthw;
	pwt = (finalwt*4/12)*totalpopgrowthw; *annualize finalwt and adjust for ORG sample;
	end;
  else if race5=2 then do;
	rc='2Black                 ';
	wgt=(orgwt/12)*totalpopgrowthb;
	pwt = (finalwt*4/12)*totalpopgrowthb; *annualize finalwt and adjust for ORG sample;
	end;
  else if race5=3 then do;
	rc='3Hispanic                 ';
	wgt=(orgwt/12)*totalpopgrowthh;
	pwt = (finalwt*4/12)*totalpopgrowthh; *annualize finalwt and adjust for ORG sample;
	end;
  else if race5=4 then do;
	rc='4Asian                   ';
	wgt=(orgwt/12)*totalpopgrowtha;
	pwt = (finalwt*4/12)*totalpopgrowtha; *annualize finalwt and adjust for ORG sample;
	end;
  else do;
	rc='5Other race/ethnicity   ';
	wgt=(orgwt/12)*totalpopgrowtho;
	pwt = (finalwt*4/12)*totalpopgrowtho; *annualize finalwt and adjust for ORG sample;
	end;

if (sex ne 1 and _race ne 1) then woc=1;
else woc=0;

*if vetever=1 then vetc='Veteran';
*else vetc='Not veteran';

if (ownchld>=1) then do;
	alone=0;
  if(sex=1) then workpar='Work dad';
  	else workpar='Work mom';
  if (1<=marstat<=2) then childc='1Married parent       ';
    else do;
		childc='2Single parent';
		if(sex=1) then singpar='Sing dad';
		else singpar='sing mom';
		end;
   end;
else do;
  if (1<=marstat<=2) then do;
	childc="3Married, no kids";
	alone=0;
  end;
   else do;
	childc="4Unmarried, no kids";
	alone=1;
   end;
end;

if (1<=famy<=3) then faminc='01less than $10,000';
  else if (4<=famy<=5) then faminc='02$10,000 - $14,999';
  else if (famy=6) then faminc='03$15,000 - $19,999';
  else if (famy=7) then faminc='04$20,000 - $24,999';
  else if (famy=8) then faminc='05$25,000 - $29,999';
  else if (famy=9) then faminc='06$30,000 - $34,999';
  else if (famy=10) then faminc='07$35,000 - $39,999';
  else if (famy=11) then faminc='08$40,000 - $49,999';
  else if (famy=12) then faminc='09$50,000 - $59,999';
  else if (famy=13) then faminc='10$60,000 - $74,999';
  else if (famy=14) then faminc='11$75,000 - $99,999';
  else if (famy=15) then faminc='12$100,000 - $149,999';
  else if (famy=16) then faminc='12$150,000 or more';

if (famy=1) then inc=2500;
else if (famy=2) then inc=6250;
else if (famy=3) then inc=8750;
else if (famy=4) then inc=11250;
else if (famy=5) then inc=13750;
else if (famy=6) then inc=17500;
else if (famy=7) then inc=22500;
else if (famy=8) then inc=27500;
else if (famy=9) then inc=32500;
else if (famy=10) then inc=37500;
else if (famy=11) then inc=45000;
else if (famy=12) then inc=55000;
else if (famy=13) then inc=67500;
else if (famy=14) then inc=87500;
else if (famy=15) then inc=125000;
else if (famy=16) then inc=200000;

if (1<=famy<=3) then faminc2='01less than $10,000     ';
  else if (4<=famy<=5) then faminc2='02$10,000 - $14,999    ';
  else if (6<=famy<=7) then faminc2='03$15,000 - $24,999    ';
  else if (8<=famy<=9) then faminc2='04$25,000 - $34,999    ';
  else if (10<=famy<=11) then faminc2='05$35,000 - $49,999    ';
  else if (12<=famy<=13) then faminc2='06$50,000 - $74,999    ';
  else if (famy=14) then faminc2='07$75,000 - $99,999    ';
  else if (famy=15) then faminc2='08$100,000 - $149,999    ';
  else if (famy=16) then faminc2='09$150,000 or more    ';

if sector=5 then sectc='Non-profit     ';
else if (1<=sector<=3) then sectc='Government    ';
else if sector=4 then sectc='For profit    ';
else sectc='Selfemp    ';

if (1<=hourwk<20) then hourc="1Part time (< 20 hours)  ";
 else if (20<=hourwk<35) then hourc="2Mid time (20-34 hours)";
 else if (hourwk>=35) then hourc="3Full time (35+ hours)";

if (majind=3) then indc="01Construction                               ";
 else if (majind=4) then indc="02Manufacturing                         ";
 else if (4670<=indcode<=5790) then indc="03Retail                      ";
 else if (majind=1) then indc="04Agro, forest, fish                       ";
 else if (majind=5) then indc="05Wholesale                     ";
 else if (majind=6) then indc="06transport and utils                    ";
 else if (majind=7) then indc="07Information                     ";
 else if (majind=8) then indc="08Financial activities                        ";
 else if (7580<=indcode<=7790) then indc="09Admin & waste management svcs      ";
 else if (majind=9) then indc="10Professional_science_mgmt                ";
 else if (7860<=indcode<=7890) then indc="11Education                 ";
 *else if (majind=10) then indc="12Health & Social svcs                 ";
 else if (7970<=indcode<=8290)then indc="12Healthcare             ";
 else if (8370<=indcode<=8470) then indc="13Social assistance";
 else if (8560<=indcode<=8670) then indc="14Arts, ent, rec, accommodation";
 else if (8680<=indcode<=8690) then indc="15Food & drink service ";
 *else if (majind=11) then indc="13Leisure hosp                    ";
 else if (9370<=indcode<=9590) then indc="16Public administration       ";
 else if majind=2 then indc="17Mining            ";
 else indc="99Other            ";

if (majocc=4) then occ_c="04Sales                  ";
 else if (majocc=1) then occ_c="01Management";
 else if (majocc=2) then occ_c="02professional";
 else if (majocc=3) then occ_c="03service";
 else if majocc=5 then occ_c="05office, admin support";
 else if majocc=6 then occ_c="06farm, for, fish";
 else if (majocc=7) then occ_c="07constr, extr";
 else if (majocc=8) then occ_c="08install, maint,repair";
 else if majocc=10 then occ_c="10transportation";
 else occ_c="99Other Occ";

if (ed<=38) then edc="1Less than high school";
 else if (ed<=39) then edc="2High School";
 else if (40=ed) then edc="3Some college, no degree";
 else if (41<=ed<=42) then edc="4AA degree";
 else if (43<=ed) then edc="5Bachelor's or higher";

p_inc = wage4*52*hourwk;

if (inc>0) then do;
  if (p_inc < inc) then do;
		percent_inc = p_inc/inc;
		soleprovider = 0;
		end;
     else do;
		percent_inc = 1;
		soleprovider = 1;
		end;
end;

if(age>=16 and wage4>0 and 1<=pemlr<=2) then do;
 worker=1;

 /*Identify tipped workers*/
 if occode in (4110,4040,4400,4500,4510,4520) then do;
	tipped=1; *removed massage therapists;
	tipc='Tipped         ';
	end;
  else if (occode in (4120,4130) and indcode in (8580,8590,8660,8670,8680,8690,8970,8980,8990,9090)) then do;
	tipped=1; 
	tipc='Tipped         ';
	end;
  *added waiters, nonrestaurant, and dining room and cafeteria attendants and bartender helpers for select industries;
  else do;
	tipped=0;
	tipc='Not tipped  ';
	end;
end;
run;

data wage_mins;
set wage_mins;

/* NYC separate minimum wage */
if state=21 then do;
	if (cbsa=35620 and cencity=1) then do;
		stmin2017=11.00;
		stmin2018=13.00;
		stmin2019=15.00;
		stmin2020=15.00;
		stmin2021=15.00;
		stmin2022=15.00;
		stmin2023=15.00;
		stmin2024=15.00;
		stmin2025=15.00;

		tipmin2017=7.50;
		tipmin2018=8.65;
		tipmin2019=10.00;
		tipmin2020=10.00;
		tipmin2021=10.00;
		tipmin2022=10.00;
		tipmin2023=10.00;
		tipmin2024=10.00;
		tipmin2025=10.00;
	end;
	else if (cbsa=35620 and cencity=2) then do;
		stmin2017=10.00;
		stmin2018=11.00;
		stmin2019=12.00;
		stmin2020=13.00;
		stmin2021=14.00;
		stmin2022=15.00;
		stmin2023=15.00;
		stmin2024=15.00;
		stmin2025=15.00;

		tipmin2017=7.50;
		tipmin2018=7.50;
		tipmin2019=8.00;
		tipmin2020=8.65;
		tipmin2021=9.31;
		tipmin2022=10.00;
		tipmin2023=10.00;
		tipmin2024=10.00;
		tipmin2025=10.00;
	end;
end;
 %cut(0); run;*initial wage distribution before first increase;

data wage_mins;
set wage_mins;
if worker=1 then do;

 if (&growthdum=1) then do; 
	wage4 = wage4*(((&monthstoincrease1/12)*(&wagegrowth1-1))+1);
 end;
 /****Capture changes in state mins between data year and first year of simulation****/
 if (stmin&year_proposal1>stmin&year_data) then do; *in state where the minimum wage changed;
   if (tipped=0) then do;
  	 if (wage4<(stmin&year_proposal1*1.15)) then do;
	 	 if (wage4<stmin&year_data) then wage4=((wage4/stmin&year_data)*stmin&year_proposal1);
		 else if (stmin&year_data<=wage4<(stmin&year_proposal1*1.15)) then do;
			 if (wage4+(0.25*((stmin&year_proposal1*1.15)-wage4)))<stmin&year_proposal1 then wage4=stmin&year_proposal1;
			 else wage4=(wage4+(0.25*((stmin&year_proposal1*1.15)-wage4))); *if (wage4+(0.25*((stmin&year_proposal1*1.15)-wage4)))>=stmin&year_proposal1 then ;
		 end;
	 end;
   end; *end nontipped;
  else if (tipped=1) then do;
	if (tipmin&year_proposal1>tipmin&year_data) then do; *reg min changes, so does tipped min;
		if (1<wage4<tipmin&year_data) then wage4=((wage4/tipmin&year_data)*tipmin&year_proposal1);
		else if (tipmin&year_data<=wage4<stmin&year_data) then wage4=wage4+(tipmin&year_proposal1-tipmin&year_data);
		else if (stmin&year_data<=wage4<stmin&year_proposal1) then do;
			if (wage4+(tipmin&year_proposal1-tipmin&year_data))>stmin&year_proposal1 then wage4=wage4+(tipmin&year_proposal1-tipmin&year_data);
			else wage4=stmin&year_proposal1;
		end;
		else wage4=wage4;
	end; *end tip min changes;
	else do; *reg min changes, no change in tipped min;
		if wage4<stmin&year_data then wage4=((wage4/stmin&year_data)*stmin&year_proposal1);
		else if (stmin&year_data<=wage4<(stmin&year_proposal1)) then do;
			if (wage4+(0.25*((stmin&year_proposal1*1.15)-wage4)))<stmin&year_proposal1 then wage4=stmin&year_proposal1;
			else wage4=(wage4+(0.25*((stmin&year_proposal1*1.15)-wage4))); *if (wage4+(0.25*((stmin&year_proposal1*1.15)-wage4)))>=stmin&year_proposal1 then ;
		end;
		else wage4=wage4;
	end; *end no change tipped min;
  end; *end tipped;
 end; *end capture changes in state mins before first step;

 wage4cf=wage4;

 raise=.;
 draise=.;
 iraise=.;

 indirect_cutoff1 = &newrate1*1.15; *Per Arin's Frictions paper; 
 *indirect_cutoff1 = &newrate1 + (&newrate1 - stmin&year_proposal); * this cutoff changes with size of increase; 

if tipped=0 then do;
	 * identify directly affected workers;
	 if (stmin&year_proposal1 < &newrate1) then do;* for workers in states with min below new rate;
	   if (((.8*stmin&year_proposal1)) <=wage4< &newrate1) then do; 
		 direct=1; *if between old min and new direct=1;
	 		* Calc raise: first check if state min is now larger than wage4;
			raise = max((&newrate1 - wage4),(.25*(indirect_cutoff1 - wage4)));
			draise=raise;
			end; *end direct check;
	   else direct=0;
	   end;
	 else direct=0;

	*Identify indirectly affected workers;
	if (stmin&year_proposal1 < &newrate1) then do;* for workers in states with min below new rate;
	  if (&newrate1 <= wage4 < indirect_cutoff1) then do;
	    indirect=1;
		raise = .25*(indirect_cutoff1 - wage4); *assumption is that indirectly affected workers will see their wages rise by 1/4 distance to the cutoff.;
		iraise=raise;
		end;
	  else indirect=0;
	  end;
	else indirect=0;
end;*tipped=0 block;
else if tipped=1 then do;
	 * identify directly affected workers;
	 if (tipmin&year_proposal1 < &tiprate1) then do;* for workers in states with tipmin below new rate;
	   if ((.8*tipmin&year_proposal1) <=wage4< &newrate1) then do; 
		 direct=1; *if between old min and new direct=1;
	 		* Calc raise: first check if state min is now larger than wage4;
			raise = &tiprate1-tipmin&year_proposal1;
			draise=raise;
			end;
	   else direct=0;
	   end;
	 else direct=0;

	*Identify indirectly affected workers;
	if (tipmin&year_proposal1 < &tiprate1) then do;* for workers in states with tipmin below new rate;
	  if (&newrate1 <= wage4) then do;
	    indirect=1;
		raise = (&tiprate1-tipmin&year_proposal1)*.5; 
		iraise=raise;
		end;
	  else indirect=0;
	  end;
	else indirect=0;
end;*tipped=1 block;

if (direct=1 and wage4>0) then p_incd = wage4*hourwk*52;
if (indirect=1 and wage4>0) then p_inci=wage4*hourwk*52;
if ((direct=1 or indirect=1) and wage4>0) then p_inca=wage4*hourwk*52;

if (direct=1 and ownchld>0) then directparent=1;
if (indirect=1 and ownchld>0) then indirectparent=1;

if direct=1 or indirect=1 then affected=1;
else affected=0;

wage4cfa=wage4cf*affected;
wage4cfd=wage4cf*direct;
wage4cfi=wage4cf*indirect;
wage4a=wage4*affected;
wage4d=wage4*direct;
wage4i=wage4*indirect;

wagebill = raise*hourwk*52; * stimulus effect of increase.  DC (10/3/11): Should this be 50 weeks or 52??;
dwagebill = draise*hourwk*52; *just for directly affected;
iwagebill = iraise*hourwk*52; *just for indirectly affected;

annwagecf=wage4cf*hourwk*52;
annwagecfa=annwagecf*affected;
annwagecfd=annwagecf*direct;
annwagecfi=annwagecf*indirect;

if wagebill>0 then annraise=wagebill;
else annraise=0;

if (direct) then do;
  directpct = direct*percent_inc;
  totalpct=directpct;
  *raisedinc = (wage4+raise) * hourwk*52;
end;
if (indirect) then do;
  indirectpct = indirect*percent_inc;
  totalpct=indirectpct;
end;
end; *workers loop;

statec=put(state,statef.);
run;

%cut(1);run;

data wage_mins;
set wage_mins;
if annraise<=0 then annraise=.;
if wagebill<=0 then wagebill=.; *NEW;
if annwagecf<=0 then annwagecf=.;
if annwagecfa<=0 then annwagecfa=.;
if annwagecfd<=0 then annwagecfd=.;
if annwagecfi<=0 then annwagecfi=.;
if wage4a<=0 then wage4a=.;
if wage4d<=0 then wage4d=.;
if wage4i<=0 then wage4i=.;

if wage4a>0 then do;
dwagea=(wage4a+raise)-wage4cfa;
danninc=dwagea*hourwk*52;
end;
if wage4d>0 then do;
dwaged=(wage4d+draise)-wage4cfd;
dannincd=dwaged*hourwk*52;
end;
if wage4i>0 then do;
dwagei=(wage4i+iraise)-wage4cfi;
danninci=dwagei*hourwk*52;
end;
run;


%macro calcfirst(yr);
/*Calculate total figures for directly and indirectly affected, wage bill, stimulus*/
* Find total number of people directly + ind affected;

proc means data=wage_mins(where=&conds) noprint; 
var pop direct indirect annwagecf dwagebill iwagebill wagebill danninc annwagecfa annwagecfd annwagecfi dannincd danninci dwagea dwaged dwagei;
weight wgt;
*by state;
output out=a (drop=_type_ mpop sdwagea sdwaged sdwagei) sum=pop direct indirect annwagecf dwagebill iwagebill wagebill danninc annwagecfa annwagecfd annwagecfi dannincd danninci sdwagea sdwaged sdwagei
								mean=mpop mdirect mindirect mannwagecf mDraise mIraise mraise mdanninc mannwagecfa mannwagecfd mannwagecfi mdannincd mdanninci mdwagea mdwaged mdwagei;
run;

data a;
set a;
year=&yr;
total=direct+indirect;
sharecat=total/pop;
run;
*Create a dataset to combine other datasets to,
 standardize category variable name to be <categ>;
data combined;
set a;
run;
%mend;

%calcfirst(&year_proposal1);run;

*This macro inputs a category name and creates statistics for
the resulting categories, then adds them to dataset <combined>
pop is the total number in categ, direct is the number directly affected;
%macro combine(type);
  proc means data=wage_mins(where=&conds) noprint;
  var pop direct indirect annwagecf dwagebill iwagebill wagebill danninc annwagecfa annwagecfd annwagecfi dannincd danninci dwagea dwaged dwagei;
  weight wgt;
  class &type;
  *by state;
  output out=temp (drop=_type_ mpop sdwagea sdwaged sdwagei) sum=pop direct indirect annwagecf dwagebill iwagebill wagebill danninc annwagecfa annwagecfd annwagecfi dannincd danninci sdwagea sdwaged sdwagei
									 mean=mpop mdirect mindirect mannwagecf mDraise mIraise mraise mdanninc mannwagecfa mannwagecfd mannwagecfi mdannincd mdanninci mdwagea mdwaged mdwagei;

  data temp;
  set temp;
  if _n_=1 then delete; *remove first obs which has total number;
  rename &type = categ; *rename type variable to match combined; 
  	total=direct+indirect;
	sharecat=total/pop;

  data combined;
  set combined temp;
%mend combine;
run;

*Run the combine macro on the following categories: age, race, parent, family income;
%combine(sexc);
%combine(agec1);
%combine(agec2);
%combine(rc);
%combine(childc);
%combine(faminc2);
%combine(indc);
%combine(occ_c);
%combine(hourc);
%combine(edc);
%combine(sectc);
%combine(statec);
%combine(tipc);
*%combine(workpar);
*%combine(singpar);
*%combine(vetc);
run;


%macro kids();
/* PARENTS AFFECTED BY INCREASE */

*Create a variable thats 1 if any parent is min wage worker;
proc sql;
      create table orgkids as
      select *,max(directparent) as parentsdirect
      from wage_mins(where=(&kconds))
      group by famid_2;

proc sql;
      create table orgkids2 as
      select *,max(indirectparent) as parentsindirect
      from orgkids
      group by famid_2;

/*
proc sort data=orgkids2;
by state;
run;
*/
*count children with directly affected parent;*had to separate out into three separate means bc we were double counting children with both directly and indirectly affected parents;
proc means data=orgkids2 (where=(age<18)) noprint;
var pop;
weight pwt;
*by state;
output out=children (drop=_type_) sum=pop;
run;
proc means data=orgkids2 (where=(age<18 and parentsindirect ne 1)) noprint;
var parentsdirect;
weight pwt;
*by state;
output out=children2 (drop=_type_ _freq_) sum=direct;
run;
proc means data=orgkids2 (where=(age<18  and parentsdirect ne 1)) noprint;
var parentsindirect;
weight pwt;
*by state;
output out=children3 (drop=_freq_ _type_) sum=indirect;
run;
/*
proc sort data=children;
by state;
run;
proc sort data=children2;
by state;
run;
proc sort data=children3;
by state;
run;
*/
data children;
merge children children2 children3;
categ = 'children';
*by state;
run;
/*
proc sort data=combined;
by state;
run;
*/
data combined;
set combined children;
*by state;
run;
%mend;

%kids;run;

%macro famincsole(i);
/*Calculating percentage of family income contributed by mw worker*/

proc means data=wage_mins(where=(&conds & (direct=1 | indirect=1) & alone=0)) noprint; *all affected;
var percent_inc soleprovider;
weight wgt;
*by state;
output out=affectpercentall (drop=_type_) mean= ampercent_inc amsole;
run;

proc means data=wage_mins(where=(&conds & (direct=1 | indirect=1) & (directparent=1 | indirectparent=1) & alone=0)) noprint; *all affected parents;
var percent_inc soleprovider;
weight wgt;
*by state;
output out=affectpercentrents (drop=_type_) mean= pmpercent_inc pmsole;
run;

data affectedincome&i;
set affectpercentall affectpercentrents;
*by state;
run;
%mend;

%famincsole(1);run;

/*state breakdown*/
/*
proc means data=wage_mins(where=(&conds)) noprint;
  var pop direct indirect wagebill;
  weight wgt;
  class state;
  output out=states (drop=_type_) sum=pop direct indirect wagebill mean=mpop mdirect mindirect mwagebill;
*/
/* EXPORT THE DATA */
data year1;
format categ _FREQ_ pop direct mdirect indirect mindirect total sharecat dwagebill mDraise annwagecfd mannwagecfd dannincd mdannincd mdwaged 
		iwagebill mIraise annwagecfi mannwagecfi danninci mdanninci mdwagei wagebill mraise annwagecfa mannwagecfa danninc mdanninc mdwagea annwagecf mannwagecf ;
set combined;
run;

PROC EXPORT DATA= year1
            OUTFILE= &outfile
            DBMS=EXCEL REPLACE;
     SHEET="Year1"; 
RUN;

PROC EXPORT DATA= affectedincome1
            OUTFILE= &outfile
            DBMS=EXCEL REPLACE;
     SHEET="Income year1"; 
RUN;

/*

PROC EXPORT DATA= states
			OUTFILE= &outfile
            DBMS=EXCEL REPLACE;
     SHEET="states year1"; 
RUN;
*/

/******************Macro start for subsequent steps*********************/

%macro iterateMW();
%do n=2 %to &numsteps;
	%let m=%eval(&n-1);

	proc delete data=combined;
	*proc delete data=year1;
	*proc delete data=bystate1;
	proc delete data=a;
	proc delete data=temp;
	proc delete data=orgkids;
	proc delete data=orgkids2;
	proc delete data=children;
	proc delete data=affectpercentall;
	proc delete data=affectpercentrents;
	*proc delete data=directout;
	*proc delete data=indirectout;
	*proc delete data=states;
	run;

	/* Re-estimate wage and job growth over period since previous step-increase in MW */

	* Input most recent data;
	data wage_mins (drop=raise draise iraise dwagebill iwagebill famid_2 p_inc direct indirect affected wagebill directpct indirectpct raisedinc totalpct percent_inc 
		soleprovider wage4a wage4d wage4i wage4cfd wage4cfi wage4cfa dwagea dwagei dwaged danninc annwagecf annwagecfd annwagecfi annwagecfa dannincd danninci);
	 set wage_mins;

	 if directparent=1 then directparent=0;
	 if indirectparent=1 then indirectparent=0;
	 if direct=1 then direct=0;
	 if indirect=1 then indirect=0;
	 if affected=1 then affected=0;
	 if(raise>0) then do;
		wage4 = (wage4 + raise)*((0.5*((&&monthstoincrease&n/12)*(&&wagegrowth&n-1)))+1); *apply the raise;
		wage4cf = wage4cf*(((&&monthstoincrease&n/12)*(&&wagegrowth&n-1))+1);
		end;
	 	else do;
			wage4=wage4*(((&&monthstoincrease&n/12)*(&&wagegrowth&n-1))+1);
			wage4cf=wage4cf*(((&&monthstoincrease&n/12)*(&&wagegrowth&n-1))+1);
		end;
	 /* wage4 = wage4*(((&monthstoincrease2/12)*(avggrowth-1))+1); *add additional period of wage growth*/
	  /*wgt=wgt*(1+((&popgrowth-1)*(&monthstoincrease2/12))); /*add additional period of population growth*/

	if _race=1 then do;
		wgt=wgt*(((&&monthstoincrease&n/12)*(&popgrowthw-1))+1);
		pwt = pwt*(((&&monthstoincrease&n/12)*(&popgrowthw-1))+1); *annualize finalwt and adjust for ORG sample;
		end;
	  else if _race=2 then do;
		wgt=wgt*(((&&monthstoincrease&n/12)*(&popgrowthb-1))+1);
		pwt = pwt*(((&&monthstoincrease&n/12)*(&popgrowthb-1))+1); *annualize finalwt and adjust for ORG sample;
		end;
	  else if _race=3 then do;
		wgt=wgt*(((&&monthstoincrease&n/12)*(&popgrowthh-1))+1);
		pwt = pwt*(((&&monthstoincrease&n/12)*(&popgrowthh-1))+1); *annualize finalwt and adjust for ORG sample;
		end;
	  else if _race=4 then do;
		wgt=wgt*(((&&monthstoincrease&n/12)*(&popgrowtha-1))+1);
		pwt = pwt*(((&&monthstoincrease&n/12)*(&popgrowtha-1))+1); *annualize finalwt and adjust for ORG sample;
		end;
	  else do;
		wgt=wgt*(((&&monthstoincrease&n/12)*(&popgrowtho-1))+1);
		pwt = pwt*(((&&monthstoincrease&n/12)*(&popgrowtho-1))+1); *annualize finalwt and adjust for ORG sample;
		end;

	 *wgt=wgt*(((&monthstoincrease2/12)*(&popgrowth-1))+1); 
	 *pwt=pwt*(((&monthstoincrease2/12)*(&popgrowth-1))+1);

	run;

	data wage_mins;
	set wage_mins;

  /***account for scheduled increases between each proposal year***/
	if(stmin&&year_proposal&n>stmin&&year_proposal&m) then do; 
	 if (tipped=0) then do;
		if (wage4<(stmin&&year_proposal&n*1.15)) then do;*MW-affected wage;
			if (wage4<stmin&&year_proposal&m) then wage4=((wage4/stmin&&year_proposal&m)*stmin&&year_proposal&n);
		  	else if (stmin&&year_proposal&m<=wage4<(stmin&&year_proposal&n*1.15)) then do;
				if (wage4+(0.25*((stmin&&year_proposal&n*1.15)-wage4)))<stmin&&year_proposal&n then wage4=stmin&&year_proposal&n;
			  	else wage4=(wage4+(0.25*((stmin&&year_proposal&n*1.15)-wage4))); *if (wage4+(0.25*((stmin&&year_proposal&n*1.15)-wage4)))>=stmin&&year_proposal&n then;
		  	end;
	 	end;
	 	if (wage4cf<(stmin&&year_proposal&n*1.15)) then do; *counterfactual wage;
			if (wage4cf<stmin&&year_proposal&m) then wage4cf=((wage4cf/stmin&&year_proposal&m)*stmin&&year_proposal&n);
			else if (stmin&&year_proposal&m<=wage4cf<(stmin&&year_proposal&n*1.15)) then do;
				if (wage4cf+(0.25*((stmin&&year_proposal&n*1.15)-wage4cf)))<stmin&&year_proposal&n then wage4cf=stmin&&year_proposal&n;
				else wage4cf=(wage4cf+(0.25*((stmin&&year_proposal&n*1.15)-wage4cf))); * if (wage4cf+(0.25*((stmin&&year_proposal&n*1.15)-wage4cf)))>=stmin&&year_proposal&n then;
			end;
	 	end;
	 end; *end non-tipped;
	 else if (tipped=1) then do; 
	 	if (tipmin&&year_proposal&n>tipmin&&year_proposal&m) then do; *reg min changes, so does tipped min;
			if (wage4<tipmin&&year_proposal&m) then wage4=((wage4/tipmin&&year_proposal&m)*tipmin&&year_proposal&n);
			 else if (tipmin&&year_proposal&m<=wage4<stmin&&year_proposal&m) then wage4=wage4+(tipmin&&year_proposal&n-tipmin&&year_proposal&m);
			 else if (stmin&&year_proposal&m<=wage4<stmin&&year_proposal&n) then do;
				if (wage4+(tipmin&&year_proposal&n-tipmin&&year_proposal&m))>stmin&&year_proposal&n then wage4=wage4+(tipmin&&year_proposal&n-tipmin&&year_proposal&m);
				else wage4=stmin&&year_proposal&n;
			 end;
			 else wage4=wage4;

			if (wage4cf<tipmin&&year_proposal&m) then wage4cf=((wage4cf/tipmin&&year_proposal&m)*tipmin&&year_proposal&n);
			else if (tipmin&&year_proposal&m<=wage4cf<stmin&&year_proposal&m) then wage4cf=wage4cf+(tipmin&&year_proposal&n-tipmin&&year_proposal&m);
			else if (stmin&&year_proposal&m<=wage4cf<stmin&&year_proposal&n) then do;
				if (wage4cf+(tipmin&&year_proposal&n-tipmin&&year_proposal&m))>stmin&&year_proposal&n then wage4cf=wage4cf+(tipmin&&year_proposal&n-tipmin&&year_proposal&m);
				else wage4cf=stmin&&year_proposal&n;
			end;
			else wage4cf=wage4cf;
	 	end; *end tip min change;
	 	else do; *reg min changes, no change in tipped min;
			if wage4<stmin&&year_proposal&m then wage4=((wage4/stmin&&year_proposal&m)*stmin&&year_proposal&n);
			else if (stmin&&year_proposal&m<=wage4<(stmin&&year_proposal&n)) then do;
				if (wage4+(0.25*((stmin&&year_proposal&n*1.15)-wage4)))<stmin&&year_proposal&n then wage4=stmin&&year_proposal&n;
				else wage4=(wage4+(0.25*((stmin&&year_proposal&n*1.15)-wage4))); *if (wage4+(0.25*((stmin&year_proposal1*1.15)-wage4)))>=stmin&year_proposal1 then ;
			end;
			else wage4=wage4;

			if wage4cf<stmin&&year_proposal&m then wage4cf=((wage4cf/stmin&&year_proposal&m)*stmin&&year_proposal&n);
			else if (stmin&&year_proposal&m<=wage4cf<(stmin&&year_proposal&n)) then do;
				if (wage4cf+(0.25*((stmin&&year_proposal&n*1.15)-wage4cf)))<stmin&&year_proposal&n then wage4cf=stmin&&year_proposal&n;
				else wage4cf=(wage4cf+(0.25*((stmin&&year_proposal&n*1.15)-wage4cf))); *if (wage4+(0.25*((stmin&year_proposal1*1.15)-wage4)))>=stmin&year_proposal1 then ;
			end;
			else wage4cf=wage4cf;
		end; *end no change in tipped min;
	 end; *end tipped;
	end;*end change in state min between steps;
	else do;
		wage4=wage4;
		wage4cf=wage4cf;
	end;
	run;
	

	data wage_mins;
	set wage_mins;

	raise=.;
	draise=.; *new;
	iraise=.; *new;

	worker=0;
	famid_2 = hhid*100+month;

	p_inc = wage4*52*hourwk;

	if (inc>0) then do;
	  if (p_inc < inc) then do;
			percent_inc = p_inc/inc;
			soleprovider = 0;
			end;
	     else do;
			percent_inc = 1;
			soleprovider = 1;
			end;
	end;

	if(age>=16 and wage4>0 and 1<=pemlr<=2) then do;
	worker=1;

	  indirect_cutoff&n = &&newrate&n*1.15; /*Per Dube frictions paper;*/
	 *indirect_cutoff&n = &&newrate&n + (&&newrate&n - &&newrate&m);

	 if tipped=0 then do;
		 * identify directly affected workers;
		 if (stmin&&year_proposal&n < &&newrate&n) then do;* for workers in states with min below new rate;
		   if (((.8*stmin&&year_proposal&n)) <=wage4< &&newrate&n) then do; 
			 direct=1; *if between old min and new direct=1;
		 		* Calc raise: first check if state min is now larger than wage4;
				raise = max((&&newrate&n - wage4),(.25*(indirect_cutoff&n - wage4)));
				if (wage4+raise)<wage4cf then raise=(wage4cf-wage4)+0.01; *prevent higher wage in counterfactual, adds 1 cent to keep them in affected sample for wage calcs;
				draise=raise;
				end;
		   else direct=0;
		   end;
		 else direct=0;

		*Identify indirectly affected workers;
		if (stmin&&year_proposal&n < &&newrate&n) then do;* for workers in states with min below new rate;
		  if (&&newrate&n <= wage4 < indirect_cutoff&n) then do;
		    indirect=1;
			raise = .25*(indirect_cutoff&n - wage4); *assumption is that indirectly affected workers will see their wages rise by 1/4 distance to the cutoff.;
			if (wage4+raise)<wage4cf then raise=(wage4cf-wage4)+0.01; *prevent higher wage in counterfactual, adds 1 cent to keep them in affected sample for wage calcs;
			iraise=raise;
			end;
		  else indirect=0;
		  end;
		else indirect=0;
	end;*tipped=0 block;
	else if tipped=1 then do;
		 * identify directly affected workers;
		 if (tipmin&&year_proposal&n < &&tiprate&n) then do;* for workers in states with tipmin below new rate;
		   if ((.8*tipmin&&year_proposal&n) <=wage4< &&newrate&n) then do; 
			 direct=1; *if between old min and new direct=1;
		 		* Calc raise: first check if state min is now larger than wage4;
				raise = min(&&tiprate&n-tipmin&&year_proposal&n, &&tiprate&n-&&tiprate&m);
				if (wage4+raise)<wage4cf then raise=(wage4cf-wage4)+0.01; *prevent higher wage in counterfactual, adds 1 cent to keep them in affected sample for wage calcs;
				draise=raise;
				end;
		   else direct=0;
		   end;
		 else direct=0;

		*Identify indirectly affected workers;
		if (tipmin&&year_proposal&n < &&tiprate&n) then do;* for workers in states with tipmin below new rate;
		  if (&&newrate&n <= wage4) then do;
		    indirect=1;
			raise = (min(&&tiprate&n-tipmin&&year_proposal&n, &&tiprate&n-&&tiprate&m))*.5; 
			if (wage4+raise)<wage4cf then raise=(wage4cf-wage4)+0.01; *prevent higher wage in counterfactual, adds 1 cent to keep them in affected sample for wage calcs;
			iraise=raise;
			end;
		  else indirect=0;
		  end;
		else indirect=0;
	end;*tipped=1 block;

	if (direct=1 and wage4>0) then p_incd = wage4*hourwk*52;
	if (indirect=1 and wage4>0) then p_inci=wage4*hourwk*52;

	if (direct=1 and ownchld>0) then directparent=1;
	if (indirect=1 and ownchld>0) then indirectparent=1;

	if direct=1 or indirect=1 then affected=1;
	else affected=0;


		wage4cfa=wage4cf*affected;
		wage4cfd=wage4cf*direct;
		wage4cfi=wage4cf*indirect;
		wage4a=wage4*affected;
		wage4d=wage4*direct;
		wage4i=wage4*indirect;

		wagebill = raise*hourwk*52; * stimulus effect of increase.  DC (10/3/11): Should this be 50 weeks or 52??;
		dwagebill = draise*hourwk*52; *just for directly affected;
		iwagebill = iraise*hourwk*52; *just for indirectly affected;

		annwagecf=wage4cf*hourwk*52;
		annwagecfa=annwagecf*affected;
		annwagecfd=annwagecf*direct;
		annwagecfi=annwagecf*indirect;

		if wagebill>0 then annraise=wagebill;
		else annraise=0;


	if (direct) then do;
	  directpct = direct*percent_inc;
	  totalpct=directpct;
	  *raisedinc = (wage4+raise) * hourwk*52;
	end;
	if (indirect) then do;
	  indirectpct = indirect*percent_inc;
	  totalpct=indirectpct;
	end;

	end; *workers loop;
	run;

	%cut(&n);run;

	data wage_mins;
	set wage_mins;

		if annraise<=0 then annraise=.; 
		if wagebill<=0 then wagebill=.; 
		if dwagebill<=0 then dwagebill=.;
		if iwagebill<=0 then iwagebill=.;
		if annwagecf<=0 then annwagecf=.;
		if annwagecfa<=0 then annwagecfa=.;
		if annwagecfd<=0 then annwagecfd=.;
		if annwagecfi<=0 then annwagecfi=.;
		if wage4a<=0 then wage4a=.;
		if wage4d<=0 then wage4d=.;
		if wage4i<=0 then wage4i=.;

		dwagea=(wage4a+raise)-wage4cfa;
		danninc=dwagea*hourwk*52;
		dwaged=(wage4d+draise)-wage4cfd;
		dannincd=dwaged*hourwk*52;
		dwagei=(wage4i+iraise)-wage4cfi;
		danninci=dwagei*hourwk*52;

		if dwagea<=0 then dwagea=.;*new;*changed to 0 from .;
		if dwaged<=0 then dwaged=.;*new;*changed to 0 from .;
		if dwagei<=0 then dwagei=.;*new;*changed to 0 from .;
		if danninc<=0 then danninc=.;*new;*changed to 0 from .;
		if dannincd<=0 then dannincd=.;*new;*changed to 0 from .;
		if danninci<=0 then danninci=.;*new;*changed to 0 from .;

	run;

	%calcfirst(&&year_proposal&n);run; *establish initial total statistics and combined dataset;

	*Run the combine macro on the various demographic categories: age, race, parent, family income,etc;
	%combine(sexc);
	%combine(agec1);
	%combine(agec2);
	%combine(rc);
	%combine(childc);
	%combine(faminc2);
	%combine(indc);
	%combine(occ_c);
	%combine(hourc);
	%combine(edc);
	%combine(sectc);
	%combine(statec);
	%combine(tipc);*/
	*%combine(workpar);
	*%combine(singpar);
	*%combine(vetc);

	run;
	%kids;run; *count kids affected by increase;

	data year&n;
	format categ _FREQ_ pop direct mdirect indirect mindirect  total sharecat dwagebill mDraise annwagecfd mannwagecfd dannincd mdannincd mdwaged 
		iwagebill miraise annwagecfi mannwagecfi danninci mdanninci mdwagei wagebill mraise annwagecfa mannwagecfa danninc mdanninc mdwagea annwagecf mannwagecf;
	set combined;
	run;

%famincsole(&n);run; *Calculating percentage of family income contributed by mw worker;

PROC EXPORT DATA= year&n
            OUTFILE= &outfile
            DBMS=EXCEL REPLACE;
     SHEET="Year&n"; 
RUN;

PROC EXPORT DATA= affectedincome&n
            OUTFILE= &outfile
            DBMS=EXCEL REPLACE;
     SHEET="Income year&n"; 
RUN;

%end;
%mend;

%iterateMW; run;

PROC EXPORT DATA= cutout
            OUTFILE= &outfile
            DBMS=EXCEL REPLACE;
     SHEET="cuts"; 
RUN;

PROC EXPORT DATA= freqout
            OUTFILE= &outfile
            DBMS=EXCEL REPLACE;
     SHEET="freq_table"; 
RUN;



